import numpy as np
from cmath import inf
import matplotlib.pyplot as plt
from opendrift.models.oceandrift import OceanDrift
from opendrift.readers import reader_netCDF_CF_generic
import xarray as xr
import os


def FTLE(DataArray, outfile=None, separation = None, duration=None, model=True, model_file = '/lustre/storeB/project/fou/hi/barents_eps/eps/barents_mean_20231018T06Z.nc', RLCS = False, show=False):
    """
        Computes LCSs using the FTLE approach using the file from ParticleAdvector.py
        The function is tailored for attracting hyperbolic LCSs. If repelling LCSs are of interest, the resulting array needs to be reversed, i.e. RLCS[::-1, ::-1].
    Args:
        DataArray  [xr.DataArray]    :   Name of file which contains intial and final positions of particles. Generated by ParticleAdvector.py
        outfile    [str]             :   Name of file where LCSs are saved to.
        DG         [bool]            :   Set to "True" if LCSs are to be generated for the Double-Gyre system. 
    Retunts:  
        outfile.nc [str]             :   Name of file where LCSs are saved to. 
    """
    if separation is not None:
        sep = separation
    else:
        sep = DataArray.separation.values
    if duration is not None:
        dur = duration
    else:
        dur = DataArray.duration.values

    x0 = np.array(DataArray.lon)
    y0 = np.array(DataArray.lat)

    nx, ny = x0.shape[0], x0.shape[1]
    x1 = np.reshape(np.array(DataArray.nlon), (nx, ny))
    y1 = np.reshape(np.array(DataArray.nlat), (nx, ny))

    ftle = np.zeros([nx,ny])
    for i in range(1,nx-1):
        for j in range(1,ny-1):
            
            F = np.zeros([2,2])
            F[0,0] = (x1[i+1, j]-x1[i-1, j])/(2*sep)
            F[0,1] = (x1[i, j+1]-x1[i, j-1])/(2*sep)
            F[1,0] = (y1[i+1, j]-y1[i-1, j])/(2*sep)
            F[1,1] = (y1[i, j+1]-y1[i, j-1])/(2*sep)
            
            C = np.dot(np.transpose(F), F)
            try:
                vals, vecs = np.linalg.eig(C)
            except:
                vals, vecs = 0
            np.seterr(divide = 'ignore')
            ftle[i,j] = np.log(np.sqrt(np.max(vals)))/dur
    ftle[ftle==-inf]=np.nan

    if RLCS is False:
        ftle = ftle[::-1,::-1]
        
    if model is True:
        # It's important to have the correct file here for the projection
        r = reader_netCDF_CF_generic.Reader(model_file)
        x0, y0 = r.xy2lonlat(x0, y0)
    
    LCS = xr.Dataset(coords = dict(lon=(['x', 'y'], x0), lat=(['x','y'], y0)),
                    data_vars = dict(ALCS=(['x', 'y'], ftle)))

    if outfile is not None:
        LCS.to_netcdf(f'{outfile}.nc')

    if show is True:
        alcs = np.array(LCS.ALCS)
        alcs[alcs>0.25] = 1
        alcs[alcs<0.25] = np.nan
        plt.pcolormesh(LCS.lon, LCS.lat, alcs, vmin = 0, vmax=1, cmap='Greys')
        plt.colorbar()
        plt.show()

    return LCS


if __name__ == '__main__':
    from ParticleAdvector import DoubleGyre#Advection
    from datetime import datetime, timedelta

    t = DoubleGyre()
    DG = t.run()
    LCS = FTLE(DG, model=False, show=True)
